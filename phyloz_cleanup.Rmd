---
title: "phylogenize_t2d"
output: html_document
date: "2025-09-17"
---

```{r setup, include=FALSE}
library(tidyverse)
library(dplyr)
library(ashr)
library(plotly)
library(ggplot2)
#------------------------------which approach is better?

#==============================APPROACH 1 -- combine result after running phylogenize:
#input:
count_2_t2d <- read.delim("~/Desktop/count_2_t2d.tab") %>% rename("X"="species_id")
count_5_t2d <- read.delim("~/Desktop/count_5_t2d_new.tab") %>% rename("X"="species_id")
count_srr_t2d <- read.delim("~/Desktop/count_srr_t2d.tab") %>% rename("X"="species_id")

#===metadata for each of the dataset:
md_2_t2d=read.delim("~/Desktop/phyloz_outs/md_2_t2d.tab")
md_5_t2d=read.delim("~/Desktop/phyloz_outs/md_5_t2d_fixed.tab")
md_srr_t2d=read.delim("~/Desktop/phyloz_outs/md_srr_t2d.tab")

#===phylogenize outputs for each dataset:
#---t2d cond:--all-results
phyloz_cond_2=read.csv("~/Desktop/phyloz_outs/all-results-t2d-2-cond.csv") %>% select(-X)
phyloz_cond_srr=read.csv("~/Desktop/phyloz_outs/all-results-t2d-srr-cond.csv") %>% select(-X)

#---met cond:
phyloz_met_5=read.csv("~/Desktop/phyloz_outs/all-results-t2d-5-met.csv")

#===check if they agree:
#for each taxon, and for genes in those taxon that are overlapped:
#--without ashr: + make plotly graph
merge_cond=inner_join(phyloz_cond_2, phyloz_cond_srr, by = c("taxon", "gene")) #!!!11k-12k genes are dropped!!!
merge_cond_split=split(merge_cond, merge_cond$taxon)
merge_cond_scatter <- lapply(names(merge_cond_split), function(name) {
  df <- merge_cond_split[[name]]
  p <- ggplot(df, aes(x = effect.size.x, y = effect.size.y, text = gene)) +
    geom_point(size = 3, color = "blue") +
    labs(
      title = paste("Scatterplot for", name),
      x = "t2d_2",
      y = "t2d_srr"
    )
  ggplotly(p, tooltip = "text")
})
merge_cond_scatter
#--with ashr:
ashr_merge_after=lapply(list(phyloz_cond_srr,
            phyloz_cond_2), function(x)
            ashr::ash.workhorse(x$effect.size,
                                x$std.err))
ash_srr=ashr_merge_after[[1]]
ash_2=ashr_merge_after[[2]]

ash2_res=cbind(phyloz_cond_2$taxon, phyloz_cond_2$gene, ash_2$result) 
colnames(ash2_res)[c(1, 2)] <- c("taxon", "gene")
ashSrr_res=cbind(phyloz_cond_srr$taxon, phyloz_cond_srr$gene, ash_srr$result)
colnames(ashSrr_res)[c(1, 2)] <- c("taxon", "gene")

#make a plot for each gene/per taxon:
merge_cond_ash=inner_join(ash2_res, ashSrr_res, by = c("taxon", "gene"))
merge_cond_ash_split=split(merge_cond_ash, merge_cond_ash$taxon)

merge_cond_scatter_ash <- lapply(names(merge_cond_ash_split), function(name) {
  df <- merge_cond_ash_split[[name]]
  p <- ggplot(df, aes(x = PosteriorMean.x, y = PosteriorMean.y, text = gene)) +
    geom_point(size = 3, color = "blue") +
    labs(
      title = paste("Scatterplot for", name),
      x = "t2d_2",
      y = "t2d_srr"
    )
  ggplotly(p, tooltip = "text")
})

#===combine with fixed effect:-check the formula again 
#function defined:
weight_func=function(ef_s1, ef_s2, std_1, std_2) {
  effs=(ef_s1*(1/std_1^2) + ef_s2*(1/std_2^2)) / ((1/std_1^2) + (1/std_2^2))
  var=1/((1/std_1^2)+(1/std_2^2))
  stder=sqrt(var)
  return(list("effs"=effs,
              "stder"=stder))
}

#before ashr:
fixed_eff_cond=weight_func(ef_s1 = merge_cond$effect.size.x,
                           ef_s2 = merge_cond$effect.size.y,
                           std_1 = merge_cond$std.err.x,
                           std_2 = merge_cond$std.err.y)
fix_eff_merge_cond=data.frame(
  taxon=merge_cond$taxon,
  gene=merge_cond$gene,
  effs=fixed_eff_cond[["effs"]],
  stder=fixed_eff_cond[["stder"]]
)


#==============================APPROACH 2 -- combine result before running phylogenize:-rerun provided phenotype phylogenize:

#apply ancombc first:
#---t2d_cond:
md2mtx=md_2_t2d %>% column_to_rownames(var="Sample")
count2mtx=count_2_t2d %>% column_to_rownames(var="species_id")
count2mtx <- as.matrix(count2mtx)
storage.mode(count2mtx) <- "numeric"

ancom_tse_2 <- TreeSummarizedExperiment::TreeSummarizedExperiment(
  assays=S4Vectors::SimpleList(counts=count2mtx),
  colData=S4Vectors::DataFrame(md2mtx))

ancom_res_tse2 <- ANCOMBC::ancombc2(ancom_tse_2,
                                   assay_name="counts",
                                   fix_formula="condition",
                                   n_cl=4)

anc_res_2=ancom_res_tse2$res

#---Srr_cond:
mdSrrmtx=md_srr_t2d %>% column_to_rownames(var="Sample")
countSrrmtx=count_srr_t2d %>% 
  select(species_id, md_srr_t2d$Sample) %>%
  column_to_rownames(var="species_id")

countSrrmtx <- as.matrix(countSrrmtx)
storage.mode(countSrrmtx) <- "numeric"

ancom_tse_Srr <- TreeSummarizedExperiment::TreeSummarizedExperiment(
  assays=S4Vectors::SimpleList(counts=countSrrmtx), #assay: 370
  colData=S4Vectors::DataFrame(mdSrrmtx))           #md: 256

ancom_res_tseSrr <- ANCOMBC::ancombc2(ancom_tse_Srr,
                                   assay_name="counts", 
                                   fix_formula="env",
                                   n_cl=4)

anc_res_srr=ancom_res_tseSrr$res

#merge two df:
anc_res_merge=inner_join(anc_res_2,anc_res_srr, by=c("taxon"))

#make "provided" phenotype tab file:
fix_eff_b4=weight_func(
  anc_res_merge$lfc_conditioncontrol,
  anc_res_merge$lfc_envcontrol,
  anc_res_merge$se_conditioncontrol,
  anc_res_merge$se_envcontrol
)

phenotype_cond=data.frame(
  species_id=as.numeric(anc_res_merge$taxon),
  estimate=fix_eff_b4$effs,
  stderr=fix_eff_b4$stder)

#==============================WHAT IF THERE WERE NO AGREEMENT at pangenome level:

```

